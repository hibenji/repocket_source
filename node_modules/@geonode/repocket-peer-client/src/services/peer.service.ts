import { debounce } from 'debounce';
import axios from 'axios';
import store from 'store2';
import { P2PEvents, P2PService } from './P2P.service';
import { peerManagerApiService } from './index';
import { getDeviceInfo } from '../shared/utils';
import { PeerMonitor } from '../classes/PeerMonitor.class';
import { VPNWatcher } from '../classes/VPNWatcher.class';
import { ConnectionMonitor } from '../classes/ConnectionMonitor.class';
import { EventEmitter } from 'node:events';

const ENDPOINTS = {
  CREATE_PEER: 'peer/createPeer',
  PEER_CONFIG: 'peer/config',
};

export interface IPeerPort {
  send(message: string): void;
}

interface RemoteSettings {
  peerMonitorRate: number;
}



// @singleton
class PeerService {
  // static final PeerService _instance = PeerService._internal();
  EVENTS_NAMES = {
    connected: 'connected',
    disconnected: 'disconnected',
    connecting: 'connecting',
    refresh_token_required: 'refresh_token_required',
    peer_server_520_error: 'peer_server_520_error',
  };

  isUserActivatedThePeer = true; // peer should be active by default
  isPeerActive = false;
  isResettingPeer = false;
  isCreatingPeer = false;
  isConnectivityChanged = false;
  shouldResetConnection = false;
  connectivityNoneTimer = null;
  vpnStatus = false;
  peerId = null;
  P2PServiceInstance: P2PService;
  peerMonitor = new PeerMonitor();
  connectionMonitor = new ConnectionMonitor();
  vpnWatcher = new VPNWatcher();
  cachedPeerActivatedEver: boolean | null = null;
  enabledLocalMonitor = false;

  tcpServerInfo = null;
  connectivitySubscription = null;
  auth = { username: 'test', password: 'test' };
  events = new EventEmitter()
  localId: number;

  settings: RemoteSettings = {
    peerMonitorRate: 120000,
  };

  constructor(options: {firebaseLoginToken?: string, sdkApiKey?: string , peerApiToken?: string, userId?: string}) {
    this.localId = Math.floor(1000 + Math.random() * 9000);

    const {firebaseLoginToken, peerApiToken, sdkApiKey, userId} = options;

    if (!firebaseLoginToken && !peerApiToken && !sdkApiKey) {
      throw new Error('firebaseLoginToken or peerApiToken or sdkApiKey is required');
    }

    if (firebaseLoginToken) store.set('loginToken', firebaseLoginToken);
    if (sdkApiKey) store.set('sdk-api-key', sdkApiKey);
    if (peerApiToken) store.set('p-api-token', peerApiToken);
    if (userId) store.set('userId', userId);

  }

  resetPeerDebounce = debounce(async () => {
    console.debug(`PeerService(${this.localId}) -> resetPeer`);
    // isPeerActive.value = false;
    await this._stop();
    this.events.emit(this.EVENTS_NAMES.connecting);
    setTimeout(async () => {
      try {
        await this.createPeer();
      } catch (error) {
        console.error(error);
      }
    }, 3000);

    setTimeout(() => {
      this.isResettingPeer = false;
    }, 5000);
  }, 1000);
  handleConnectionClosedDebounce = debounce(async () => {
    console.debug(`PeerService(${this.localId}) -> _handleConnectionClosed`);
    this.events.emit(this.EVENTS_NAMES.disconnected);
    if (this._shouldReconnectThePeer()) {
      setTimeout(async () => {
        await this._resetPeer();
      }, 3000);
    } else {
      if (!this.isUserActivatedThePeer) {
        await this.deletePeer();
      }
    }
  }, 1000);

  deletePeerDebounce = debounce(async () => {
    console.debug('deletePeerDebounce');
    await this._stop();
  }, 1000);

  _shouldReconnectThePeer() {
    return this.isUserActivatedThePeer;
  }

  async createPeer() {
    if (this.isCreatingPeer || this.isPeerActive) return false;

    this.isCreatingPeer = true;

    try {
      // Starting the local monitor before anything else, in case connection gets stuck and it never gets to peerMonitor or connectionMonitor init
      this.startLocalPeerMonitor();

      //  1. getting speed test
      //  2. getting device info
      const ipInfo = await this.getIpInfo();

      const deviceInfo = await getDeviceInfo();
      // //   3. getting ip info

      // 4. check connectivity
      const isConnectivityCheck = true; // await ConnectivityData.connectivityCheck();  todo : complete logic
      // 5. check VPN status
      const isVpnConnect = false; // await isVpnActive(); todo : complete logic

      // 6. establish connection - POST /api/peer/createPeer - payload: { ip, username, password, userId, userDeviceInfo, speedTestInfo }
      if (isConnectivityCheck && !isVpnConnect) {
        let userId = store.get('userId');
        let settings = this.settings;

        console.debug(
          `PeerService(${this.localId}) -> creating peer userId -> ${userId}`
        );
        // If we don't get a response we still want to be able to use the default values, hence the try/catch
        try {
          let remoteSettings = await peerManagerApiService.get(
            ENDPOINTS.PEER_CONFIG
          );

          let versionToken = remoteSettings.data.data.config_version_token;
          store.set('configVersionToken', versionToken);

          this.settings = settings;
        } catch (error) {
          console.debug('Failed to get settings');
        }

        let response = await peerManagerApiService.post('peer/createPeer', {
          ip: ipInfo?.query, // todo - check behavior on the server
          username: 'test',
          password: 'test',
          userId: userId,
          userDeviceInfo: deviceInfo,
        });

        if (response) {
          console.debug(
            `PeerService(${this.localId}) -> creating peer response -> ${response.status}`
          );
          response = response['data']['data'];
          this.peerId = response['_id'];
          let token = response['token'];
          this.tcpServerInfo = response['tcpServerInfo'];
          if (!userId) {
            userId = response['userId']
            store.set('userId', userId);
          }


          this.P2PServiceInstance = new P2PService({
            ip:  this.tcpServerInfo!['ip'],
            port: this.tcpServerInfo!['port'],
            socketReqHandlerPort: this.tcpServerInfo!['socketReqHandlerPort'],
            peerId: this.peerId,
            userId: userId,
            token: token,
          });

          this._registerEventListeners();
          // listenToConnectivityChanges();

          const isSocketConnected =
            await this.P2PServiceInstance?.startSocketConnection();
          if (isSocketConnected) {
            this.isUserActivatedThePeer = true;
            this.isPeerActive = true;
          }

          this.isCreatingPeer = false;
          if (isSocketConnected) {
            return true;
          } else {
            return false;
          }
        } else {
          this.isCreatingPeer = false;
          return false;
        }
      } else {
        this.isCreatingPeer = false;
        return false;
      }
    } catch (error) {
      this.isCreatingPeer = false;
      console.error(error);
      console.info(
        `PeerService(${this.localId}) -> Failed to create connection: ${error?.data?.message}`
      );
      if (error?.status === 403) {
        this.events.emit(this.EVENTS_NAMES.refresh_token_required);
      }

      if (error?.status === 520) {
        this.events.emit(this.EVENTS_NAMES.peer_server_520_error);
      }
      return false;
    }
  }

  async _handleConnectionClosed() {
    this.handleConnectionClosedDebounce();
  }

  _registerEventListeners() {
    const onSocketConnectionFailedDebounce = debounce(async () => {
      if (!this.isCreatingPeer && this.isConnectivityChanged) {
        await this._handleConnectionClosed();
      }
    }, 1000);

    const onReceiveDataDebounce = debounce(async () => {
      console.debug(
        'onSocketConnectionFailed ${isUserActivatedThePeer.isTrue}'
      );
      if (!this.isPeerActive) {
        this.isPeerActive = true;
        this.events.emit(this.EVENTS_NAMES.connected);
      }
    }, 1000);

    const onConnectionToServerFailedDebounce = debounce(async () => {
      console.debug(
        'onConnectionToServerFailed ${isUserActivatedThePeer.isTrue}'
      );

      this.events.emit(this.EVENTS_NAMES.disconnected);
      await this._stop();
    }, 1000);

    const onSocketConnectionCloseDebounce = debounce(async () => {
      console.debug(
        'onSocketConnectionClose ${isUserActivatedThePeer.isTrue}'
      );

      if (!this.isCreatingPeer) {
        // isPeerActive.value = false;
        setTimeout(async () => {
          await this._handleConnectionClosed();
        }, 1000);
      }
    }, 1000);

    const onConnectionEstablishedDebounce = debounce(async () => {
      console.info(`PeerService(${this.localId}) -> Connection established`);

      await this._markPeerAsAlive();
    }, 1000);

    this.P2PServiceInstance?.emitter.on(
      P2PEvents.onBeforeStartSocketConnection,
      async () => {
        this.events.emit(this.EVENTS_NAMES.connecting);
        //  register all event listeners here

        this.P2PServiceInstance?.emitter.on(
          P2PEvents.onSocketConnectionFailed,
          async () => {
            //      if connection to socket failed
            if (!this.isCreatingPeer && !this.isConnectivityChanged) {
              onSocketConnectionFailedDebounce();
            }
          }
        );

        this.P2PServiceInstance?.emitter.on(
          P2PEvents.onReceiveData,
          async () => {
            //      if connection to socket failed
            onReceiveDataDebounce();
          }
        );

        this.P2PServiceInstance?.emitter.on(
          P2PEvents.onConnectionToServerFailed,
          async () => {
            //      if connection to socket failed
            onConnectionToServerFailedDebounce();
          }
        );

        this.P2PServiceInstance?.emitter.on(
          P2PEvents.onSocketConnectionClose,
          async () => {
            //      if connection to socket failed
            onSocketConnectionCloseDebounce();
          }
        );

        this.P2PServiceInstance?.emitter.on(
          P2PEvents.onConnectionEstablished,
          async () => {
            onConnectionEstablishedDebounce();
          }
        );
      }
    );
  }

  async _resetPeer() {
    if (this.isResettingPeer) return;
    this.isResettingPeer = true;
    this.resetPeerDebounce();
  }

  async deletePeer(isForceStop = false) {
    if (this.isResettingPeer && isForceStop == false) return;

    if (isForceStop) {
      // EasyDebounce.cancel('delete-peer-debouncer');
      await this._stop();
    } else {
      this.deletePeerDebounce();
    }
  }

  async _stop(keepConnectionMonitor = false) {
    console.info(`PeerService(${this.localId}) -> Stop`);
    if (this.peerId) {
      this.peerMonitor.stop();
      if (!keepConnectionMonitor) {
        this.connectionMonitor.stop();
      }
      this.vpnWatcher.stop();
      this.events.emit(this.EVENTS_NAMES.disconnected);
      try {
        // todo - test it
        await peerManagerApiService.delete('peer/deletePeer', {
          peerId: this.peerId,
        });
      } catch (error) {
        console.error(error);
        // if (error.status === 403) {
        //   await firebaseService?.refreshToken();
        // }
      }

      this.P2PServiceInstance?.end();
      this.P2PServiceInstance?.emitter.removeAllListeners();
      this.isPeerActive = false;
      this.peerId = null;
    }
  }

  async _markPeerAsAlive() {
    try {
      console.log('markPeerAsAlive -> start - ', this.peerId);
      const response = await peerManagerApiService.post(
        'peer/markPeerAsAlive',
        {
          peerId: this.peerId,
        }
      );

      const isAlive = response.status === 200;
      if (isAlive) {
        console.log('markPeerAsAlive -> isAlive');
        this.isPeerActive = true;
        this.events.emit(this.EVENTS_NAMES.connected);
        // retriesConnectionCounter = 0;
        this.isUserActivatedThePeer = true;
        this.startPeerMonitor().then();
        this.startConnectionMonitor().then();
        this.startVpnWatcher().then();
      }
    } catch (error) {
      console.error(
        `_markPeerAsAlive -> Error happened: ${error?.data?.message}`
      );

      // if (error.status === 403) {
      //   this.events.emit(this.EVENTS_NAMES.refresh_token_required);
      // }
    }
  }


  async startPeerMonitor() {
    let userId = store.get('userId');
    let versionToken = store.get('configVersionToken');
    this.peerMonitor.init({
      peerId: this.peerId!,
      userId: userId,
      configVersionToken: versionToken,
    });

    this.peerMonitor.start(
      {
        onPeerDeactivate: async () => {
          await this._handleConnectionClosed();
        },
        onCredentialsMissing: async () => {
          await this._stop();
        },
        onPeerActive: async () => {
          this._verifyUIStatus();
        },
      },
      this.settings.peerMonitorRate
    );
  }

  async startConnectionMonitor() {
    this.connectionMonitor.init();

    this.connectionMonitor.start({
      onConnectionDeactivate: async () => {
        if (!this.shouldResetConnection) {
          this.shouldResetConnection = true;
          await this._stop(true);
        }
      },
      onConnectionActive: async () => {
        if (this.shouldResetConnection) {
          this.shouldResetConnection = false;
          await this._resetPeer();
        }
      },
    });
  }

  startLocalPeerMonitor() {
    if (!this.enabledLocalMonitor) {
      this.enabledLocalMonitor = true;
      setInterval(() => {
        if (this.isResettingPeer || this.isCreatingPeer) return;
        const isEnabled = store.get('shareInternet');
        if (isEnabled) {
          console.debug(
            'startLocalPeerMonitor -> checking for unhandled disconnects'
          );
          const status = store.get('connectionStatus');
          if (status !== 'connected') {
            console.debug(
              'startLocalPeerMonitor -> not connected, checking internet connection'
            );
            const monitor = new ConnectionMonitor();
            monitor.duration = 1000;
            monitor.start({
              onConnectionDeactivate: () => {
                console.info(
                  'startLocalPeerMonitor -> No Internet connection'
                );
                monitor.stop();
              },
              onConnectionActive: () => {
                console.debug(
                  'startLocalPeerMonitor -> Internet connection present, resetting peer'
                );
                monitor.stop();
                this._resetPeer()
                  .then(() => {
                    console.debug(
                      `startLocalPeerMonitor -> Reset peer after an unhandled disconnect`
                    );
                  })
                  .catch((error) => {
                    console.error(
                      `startLocalPeerMonitor -> Error resetting peer: ${error}`
                    );
                  });
              },
            });
          }
        }
      }, 34300);
    }
  }

  _verifyUIStatus() {
    this.isPeerActive = true;
    this.events.emit(this.EVENTS_NAMES.connected);
  }

  async startVpnWatcher() {
    let userId = store.get('userId');
    this.vpnWatcher.init({
      peerId: this.peerId,
      userId: userId,
    });

    this.vpnWatcher.start({
      onVpnActivated: async () => {
        await this.deletePeer();
      },
    });
  }

  async getIpInfo() {
    // http://ip-api.com/json
    try {
      // todo - check with https://verification.repocket.co/api/peer/verification
      const response = await axios.get('http://ip-api.com/json');

      if (response.status == 200) {
        return response.data;
      } else {
        console.error('Something went wrong');
      }
    } catch (e) {
      console.error(e.toString());
    }
  }
}

export default PeerService;
