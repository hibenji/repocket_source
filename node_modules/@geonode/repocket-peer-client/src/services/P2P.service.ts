// eslint-disable-next-line max-classes-per-file
import EventEmitter from 'events';
import { Socket } from 'net';
import { MainSocket } from '../P2P/main.socket';

const net = require('net');

export const PeerSocketEvents = {
  PeerSocketFree: '1',
  RemoteSocketClosed: '2',
  ConnectionCompleted: '3',
  Authentication: '4',
  TargetWebsiteError: '5',
  Ping: '6',
  Pong: '7',
  SocketHandlerConnectionFailed: '8',
  AuthenticationFailed: '9',
};
export class P2PEvents {
  static onConnectionEstablished = 'onConnectionEstablished';
  static onSocketConnectionFailed = 'onSocketConnectionFailed';
  static onBeforeStartSocketConnection = 'onBeforeStartSocketConnection';
  static onServerCloseSocketConnection = 'onServerCloseSocketConnection';
  static onSocketConnectionClose = 'onSocketConnectionClose';
  static onConnectionToServerFailed = 'onConnectionToServerFailed';
  static onReceiveData = 'onReceiveData';
  static onSocketClose = 'onSocketClose';
  static onCreateSocketRequestHandler = 'onCreateSocketRequestHandler';
  static onTargetWebsiteError = 'onTargetWebsiteError';
}

class RPSocket extends Socket {
  uid?: number;
  retryConnectionCounter?: number;
  isBusy?: boolean;
  type?: 'main' | 'helper' | string;
}

// @singleton
export class P2PService {
  emitter = new EventEmitter();
  _ip = '';
  _peerId = '';
  _userId = '';
  _token = '';
  _port = 0;
  _socketReqHandlerPort = 0;
  // _numOfConnections = 1;
  // _socketConnections: RPSocket[] = [];
  // serverSocketToTargetSocketMap = {};
  socketServer;
  mainSocket: MainSocket;

  retriesConnectionCounter = 0;
  MAX_RETRY_PER_HOUR = 30;
  _retriesInterval;

  // , numOfConnections = 1
  constructor({ ip, port, peerId, userId, token, socketReqHandlerPort }) {
    this._ip = ip;
    this._port = port;
    this._socketReqHandlerPort = socketReqHandlerPort;
    this._peerId = peerId;
    this._userId = userId;
    this._token = token;
    // this._numOfConnections = numOfConnections;

    if (this._retriesInterval == null) {
      this._retriesInterval = setInterval(() => {
        this.retriesConnectionCounter = 0;
      }, 1000 * 60 * 60);
    }
  }
  // @ts-ignore
  async startSocketConnection() {
    console.log('start connection');

    if (this.retriesConnectionCounter >= this.MAX_RETRY_PER_HOUR) {
      this.retriesConnectionCounter = 0;
      console.log('P2PService -> onConnectionToServerFailed');
      this.emitter.emit(P2PEvents.onConnectionToServerFailed, null, null);
      return false;
    }
    this.retriesConnectionCounter++;
    this.emitter.emit(P2PEvents.onBeforeStartSocketConnection);

    // return new Promise((res , rej) => {
    this.mainSocket = new MainSocket({
      port: this._port,
      socketReqHandlerPort: this._socketReqHandlerPort,
      ip: this._ip,
      peerId: this._peerId,
      token: this._token,
      userId: this._userId,
    });

    this.mainSocket.emitter.on(P2PEvents.onConnectionEstablished, () =>
      this.emitter.emit(P2PEvents.onConnectionEstablished, null, this._peerId)
    );

    this.mainSocket.emitter.on(P2PEvents.onSocketConnectionFailed, (error) =>
      this.emitter.emit(P2PEvents.onSocketConnectionFailed, null, error)
    );

    this.mainSocket.emitter.on(P2PEvents.onSocketConnectionClose, () =>
      this.emitter.emit(P2PEvents.onSocketConnectionClose, null, null)
    );

    const isConnected = await this.mainSocket.connect();

    if (isConnected) {
      this.retriesConnectionCounter = 0;
      return true;
    } else {
      setTimeout(async () => {
        await this.startSocketConnection();
      }, 1000 * 10);
    }

    //
  }

  end() {
    console.log('P2PService -> CLOSE SOCKET CONNECTION');
    this.mainSocket.end();
  }
}
