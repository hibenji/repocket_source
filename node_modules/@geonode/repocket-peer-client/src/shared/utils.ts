import { DeviceInfo, RuntimeInfo } from "../@types/global";
import {appVersion, isDocker, isLinux, isLinuxArm, isMac, isMacIntel, isWindows} from "./global";
import os from "os";
var network = require('network');

export const cyrb53 = (str, seed = 0) => {
    let h1 = 0xdeadbeef ^ seed,
      h2 = 0x41c6ce57 ^ seed;
    for (let i = 0, ch; i < str?.length; i++) {
      ch = str.charCodeAt(i);
      h1 = Math.imul(h1 ^ ch, 2654435761);
      h2 = Math.imul(h2 ^ ch, 1597334677);
    }

    h1 =
      Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^
      Math.imul(h2 ^ (h2 >>> 13), 3266489909);
    h2 =
      Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^
      Math.imul(h1 ^ (h1 >>> 13), 3266489909);

    return (
      (h2 >>> 0).toString(16).padStart(8, '0') +
      (h1 >>> 0).toString(16).padStart(8, '0')
    );
};

export async function getDeviceInfo(): Promise<DeviceInfo> {
    // const deviceInfo = DeviceInfoPlugin();

    const deviceName = () => {
        if (isDocker) return 'Docker Container';
        if (isMac) return 'Mac Desktop';
        if (isMacIntel) return 'Mac Intel Desktop';
        if (isWindows) return 'Windows Desktop';
        if (isLinux) return 'Linux Desktop';
        if (isLinuxArm) return 'Linux ARM Desktop';
        return 'Desktop';
    };

    const getConnectivityType: () => Promise<string> = async () =>
      new Promise((res) => {
        network.get_active_interface(function (err, obj) {
          if (err) {
            // Linux fails at this, so better to just keep it Wireless, not that important
            res('Wireless');
            return;
          }
          // obj.type is the network type
          // 'Wireless' for wifi
          // 'Wired' for ethernet
          res(obj.type);
        });
      });

    const getMacAddress: () => Promise<string> = async () =>
      new Promise((res, rej) => {
        console.log('process.platform :', process.platform);
        if (process.platform !== 'darwin' && process.platform !== 'win32') {
          network.get_interfaces_list(function (err, arr) {
            if (err || arr.length === 0) {
              rej(err);
              return;
            }
            res(arr[0].mac_address);
          });
        } else {
          network.get_active_interface(function (err, obj) {
            if (err) {
              rej(err);
              return;
            }
            res(obj.mac_address);
          });
        }
      });

    // const androidDeviceInfo = await deviceInfo.androidInfo;

    let connectivityResult = await getConnectivityType();
    console.log(connectivityResult);
    let macAddress = await getMacAddress();
    macAddress = cyrb53(macAddress);
    if (isDocker) {
      macAddress = 'docker-' + macAddress;
    }
    console.log(macAddress);
    const version = appVersion;

    return {
      cpus: os.cpus().length,
      id: macAddress,
      device: os.type(),
      isPhysicalDevice: true,
      model: os.platform(),
      version: version,
      isDesktop: true,
      buildNumber: 0,
      connectivityType: connectivityResult,
      os: deviceName(),
      osVersion: os.release()
    };
}

export function getRuntimeInfo(): RuntimeInfo {
    let osName = 'unknown-os'

    if (isDocker) {
      osName = 'sdk-node';
    } else if (isMac) {
      osName = 'sdk-mac';
    } else if (isWindows) {
      osName = 'sdk-windows';
    } else if (isLinux) {
      osName = 'sdk-linux';
    } else {
      osName = 'sdk';
    }

    return {
      // libVersion: libVersion,
      isDocker: isDocker,
      isMac: isMac,
      isLinux: isLinux,
      isWindows: isWindows,
      osName: osName
    }
}

