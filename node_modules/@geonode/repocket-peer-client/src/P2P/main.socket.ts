import { P2PEvents, PeerSocketEvents } from '../services/P2P.service';
import { Socket } from 'net';
import EventEmitter from 'events';
import { debounce } from 'debounce';
import { RequestHandlerSocket } from './request-handler.socket';

class RPSocket extends Socket {
  uid: number;
  retryConnectionCounter: number;
  isBusy: boolean;
  type: 'main' | 'helper' | string;
}

export class MainSocket {
  _port;
  _socketReqHandlerPort;
  _ip;
  _peerId;
  _token;
  _userId;
  MAX_SOCKET_RETRIES = 10; // try to recconnect for 1min
  emitter = new EventEmitter();
  mainSocket: RPSocket;
  resetConnectionDebounce: any;
  isReconnecting = false;
  onConnectionEstablishedEventFired = false;
  peerCloseWithError = false;

  constructor({ port, ip, peerId, token, userId, socketReqHandlerPort }) {
    this._ip = ip;
    this._port = port;
    this._socketReqHandlerPort = socketReqHandlerPort;
    this._peerId = peerId;
    this._token = token;
    this._userId = userId;

    this.resetConnectionDebounce = debounce(async () => {
      if (this.isReconnecting) return;
      if (this.mainSocket?.retryConnectionCounter < this.MAX_SOCKET_RETRIES) {
        this.mainSocket.setKeepAlive(true);
        this.mainSocket.setNoDelay(true);
        this.mainSocket.retryConnectionCounter++;
        console.log('MainSocket -> before re connect', this._ip);
        try {
          this.isReconnecting = true;
          this.mainSocket.connect(this._port, this._ip, () => {
            console.log('main socket re connected');
            this.mainSocket.isBusy = false;
            this.mainSocket.retryConnectionCounter--;
            this.isReconnecting = false;
            this.peerCloseWithError = false;
          });
        } catch (e) {
          console.log('main socket re connect error', e);
          this.onMainSocketCloseWIthError();
          // this.mainSocket.destroy(new Error('End socket - fail to reconnect'));
        }
      } else {
        console.log('main socket dont renew connection');
        this.onMainSocketCloseWIthError();
        // this.mainSocket.destroy(
        //   new Error('End socket - dont renew connection - too many sockets')
        // );
        this.emitter.emit(P2PEvents.onSocketConnectionClose, null, null);
      }
    }, 500);
  }

  private onMainSocketCloseWIthError() {
    this.peerCloseWithError = true;
    this.mainSocket.end();
  }

  end() {
    console.log('main socket destroy');
    this.onMainSocketCloseWIthError();
    // this.mainSocket.destroy(error);
  }

  async connect() {
    try {
      this.mainSocket = new RPSocket();
      this.mainSocket.retryConnectionCounter = 0;
      this.mainSocket.type = 'main';
      this.mainSocket.uid = Math.random();
      this.mainSocket.isBusy = false;
      this.mainSocket.setKeepAlive(true);
      this.mainSocket.setNoDelay(true);

      this.mainSocket.on('data', async (data) => {
        await this.onData(data);
      });

      this.mainSocket.on('error', (error) => {
        console.log('MainSocket -> error', error);
        this.peerCloseWithError = true;
        this.onError(error);
      });

      this.mainSocket.on('close', (hadError) => {
        console.log('MainSocket -> close', hadError);
        this.onClose(hadError);
      });

      this.mainSocket.connect(this._port, this._ip);

      // to test reconnect logic
      // setTimeout(() => {
      //   this.mainSocket.destroy(new Error('End socket - timeout test'));
      // }, 10000);
      return true;
    } catch (e) {
      return false;
    }
  }

  async _handleRead(data) {
    const request = String.fromCharCode(...new Uint8Array(data.buffer));
    const reqAsStr = request.toString();
    const isAuthPacket = reqAsStr == PeerSocketEvents['Authentication'];
    const isPingPacket = reqAsStr == PeerSocketEvents['Ping'];
    const isAuthFailedPacket =
      reqAsStr == PeerSocketEvents['AuthenticationFailed'];
    const isConnCompletedPacket =
      reqAsStr == PeerSocketEvents['ConnectionCompleted'];

    if (isAuthPacket) {
      console.log('P2PS-MainSocket -> Authentication');

      this.mainSocket.write(
        `authentication ${this._token} ${this._userId} ${this._peerId}`
      );
      return;
    } else if (isConnCompletedPacket) {
      if (this.onConnectionEstablishedEventFired) return;
      this.emitter.emit(P2PEvents.onConnectionEstablished, null, this._peerId);
      this.onConnectionEstablishedEventFired = true;
      // RPLogger.log('P2PS-MainSocket -> authorization COMPLETED');
      return;
    } else if (isPingPacket) {
      console.log('MainSocket -> PING');
      this.mainSocket.write(PeerSocketEvents['Pong']);
      return;
    } else if (isAuthFailedPacket) {
      console.log('MainSocket -> PING');
      this.onMainSocketCloseWIthError();
      // this.mainSocket.destroy(new Error('End socket - auth failed'));
      return;
    }

    const requests = reqAsStr.split('reqId:');

    console.log('req: '), requests[0];
    

    if (requests && requests.length) {
      requests.forEach((reqId) => {
        if (reqId === '' || !reqId) return;
        this.initRequestSocketHandler(reqId);
      });
    }
  }

  initRequestSocketHandler(reqId) {
    const reqHandlerSocket = new RequestHandlerSocket(
      this._ip,
      this._socketReqHandlerPort || 7072,
      reqId,
      this._peerId
    );

    reqHandlerSocket.emitter.on(P2PEvents.onSocketConnectionFailed, () =>
      this.mainSocket.write(
        `${PeerSocketEvents.SocketHandlerConnectionFailed}:${reqId}`
      )
    );

    reqHandlerSocket.emitter.on(P2PEvents.onTargetWebsiteError, () =>
      this.mainSocket.write(`${PeerSocketEvents.TargetWebsiteError}:${reqId}`)
    );

    reqHandlerSocket.connect();
  }

  async onData(data) {
    try {
      await this._handleRead(data);
    } catch (e) {
    }
  }

  onError(error) {
    this.peerCloseWithError = true;
    this.emitter.emit(P2PEvents.onSocketConnectionFailed, null, error);
  }

  onClose(hadError) {
    console.log('doneHandler', hadError);

    // !hadError
    if (!this.peerCloseWithError) {
      console.log('main socket try to re connect ', this._peerId);
      this.resetConnectionDebounce();
    } else {
      console.log('main socket dont renew connection cause of error');
      this.mainSocket.end();
      // this.mainSocket.destroy(
      //   new Error('End socket - dont renew connection - had error')
      // );
      this.emitter.emit(P2PEvents.onSocketConnectionClose, null, null);
    }
  }
}
