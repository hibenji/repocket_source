import net, { Socket } from 'net';
//  todo - fix imports
import { P2PEvents, PeerSocketEvents } from '../services/P2P.service';
import EventEmitter from 'events';
import { TargetSocket } from './target.socket';
import { writeToSocket } from './helpers';
import { Socket5Handler } from './socks5/socks5.socket';

class ReqHandlerSocket extends Socket {
  uid?: number;
  retryConnectionCounter?: number;
  isBusy?: boolean;
  type?: 'main' | 'helper' | string;
}

export class RequestHandlerSocket {
  emitter = new EventEmitter();
  _ip;
  _port;
  _reqId;
  _peerId;
  socket: ReqHandlerSocket;
  targetSocket: TargetSocket;
  socks5targetSocket: Socket5Handler;
  private isSocks5Req = false;

  constructor(ip, port, reqId, peerId) {
    this._ip = ip;
    this._port = port;
    this._reqId = reqId;
    this._peerId = peerId;
  }

  connect() {
    this.socket = new Socket();
    this.socket.retryConnectionCounter = 0;
    this.socket.type = 'main';
    this.socket.uid = Math.random();
    this.socket.isBusy = false;
    this.socket.setNoDelay(true);

    this.socket.on('data', async (data) => {
      await this.onData(data);
    });

    this.socket.on('error', (error) => {
      this.onError(error);
    });

    this.socket.on('timeout', () => {
      console.log('Socket timeout');
      this.socket.emit('error', new Error('Timeout occurred'));
      this.socket.end();
    });

    this.socket.on('close', () => {
      this.onClose();
    });

    this.socket.connect(this._port, this._ip, () => {
      console.log(`new socket req - ${this._reqId}`);
    });
  }

  // socketServer: RPSocket,
  async httpProtocolHandler(data, buffer) {
    // RPLogger.log('handling HTTPS | HTTP');
    const request = this.parseHttpRequest(data);
    if (!request) return;

    const port = request['port'] != null ? request['port'] : 80;

    try {
      this.targetSocket = new TargetSocket(this.socket, request, buffer);

      this.targetSocket.emitter.on(P2PEvents.onTargetWebsiteError, (e) =>
        this.emitter.emit(P2PEvents.onTargetWebsiteError, null, e)
      );

      this.targetSocket.connect();
    } catch (e) {
      console.log('e :', e);
      return;
    }
  }
  async _handleRead(data) {
    // authentication
    const request = String.fromCharCode(...new Uint8Array(data.buffer));
    const reqAsStr = request.toString();
    const isAuthPacket = reqAsStr == PeerSocketEvents['Authentication'];
    const isRemoteSocketClosePacket =
      reqAsStr == PeerSocketEvents['RemoteSocketClosed'];
    const httpFirstLineRegex =
      /^(GET|HEAD|POST|PUT|DELETE|OPTIONS|TRACE|PATCH|CONNECT) (\S+\s+HTTP\/1\.(0|1)(\r\n([A-Za-z0-9-_]+:\s+[\S ]+)?)+\r\n\r\n.*)*$/;

    if (isAuthPacket) {
      // RPLogger.log('RequestHandlerSocket -> Authentication');
      this.socket.write(`authentication ${this._peerId} ${this._reqId}`);
      return;
    } else if (isRemoteSocketClosePacket) {
      // RPLogger.log('received RemoteSocketClosed');
      if (this.targetSocket != null) {
        // RPLogger.log('on end');
        this.targetSocket.socket.end();
        // targetSocket.close();
      }
    } else if (this.targetSocket != null) {
      // RPLogger.log('writing data to targetSocket');
      try {
        writeToSocket(this.targetSocket.socket, data);
      } catch (e) {
        console.log('e :', e);
      }
      return;
    } else if (this.isSocks5Req) {
      // write events handled by pipe method on the socket for socks5
      return;
    }

    if (
      request.toString().startsWith('CONNECT') ||
      request.toString().includes('HTTP/1.1') ||
      httpFirstLineRegex.test(request.toString())
    ) {
      // http/https
      this.socket.isBusy = true;
      return await this.httpProtocolHandler(request, data);
    } else if (this.isSocks5Request(data)) {
      // socks5
      this.isSocks5Req = true;
      this.socks5targetSocket = new Socket5Handler(this.socket, {});
      this.socks5targetSocket.handle(data).then();
    }
  }

  isSocks5Request(buffer) {
    if (!buffer) return;
    // Check if buffer length is at least 10 bytes || Check SOCKS version || Check command code || Check reserved byte
    if (
      buffer.length < 10 ||
      buffer[0] !== 5 ||
      buffer[1] !== 1 ||
      buffer[2] !== 0
    ) {
      return false;
    }

    return true;
  }

  async onData(data) {
    try {
      await this._handleRead(data);
    } catch (e) {
      console.log('e :', e);
    }
  }

  onError(error) {
    console.log(`onError: error when connecting to socket-server: ${error}`);
    this.emitter.emit(P2PEvents.onSocketConnectionFailed, null, error);
    this.socket.end();
  }

  onClose() {
    console.log(' RequestHandlerSocket ->  onClose => ', this._reqId);
    this.socket.end();
  }

  private parseHttpVer10(data) {
    const splitted = data.split(' ');

    return {
      method: splitted[0],
      path: splitted[1].split(':')[0],
      httpVersion: splitted[2].split('\r')[0],
      host: splitted[1].split(':')[0],
      port: splitted[1].split(':')[1],
    };
  }

  private parseHttpRequest(data: any) {
    try {
      if (data && data.includes('HTTP/1.0')) {
        return this.parseHttpVer10(data);
      }

      const getPort = (host_header: string) => {
        var port;
        if (host_header.split(':').length > 2) {
          port = Number(host_header.split(':')[2].trim());
        }
        return port || 80;
      };

      const getHostIndex = (splitted: Array<string>) => {
        return splitted.findIndex(
          (l) =>
            l.toLowerCase().includes('host:') &&
            l.toLowerCase().startsWith('host: ')
        );
      };

      const splitted = data.split('\r\n');
      const firstLine = splitted[0].trim().split(' ');
      const method = firstLine[0];
      const path = firstLine[1];
      const httpVersion = firstLine[2];
      const index = getHostIndex(splitted);
      const host = splitted[index].split(':')[1].trim();
      const port = getPort(splitted[index]);

      return {
        method,
        path,
        httpVersion,
        host,
        port,
      };
    } catch (e) {
      console.log('e parseHttpRequest:', e);
      return null;
    }
  }
}
