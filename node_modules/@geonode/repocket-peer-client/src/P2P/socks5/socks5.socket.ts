import { Resolver } from 'dns';
import net from 'net';
import ipv6 from './utils/ipv6';

export class Socket5Handler {
  socket: any;
  private logger: any;
  private port: any;
  private localAddress: any;
  private dns: any;
  private userPassAuthFn: any;
  constructor(socket, options = {} as any) {
    this.socket = socket;
    this.logger = options.logger || console;
    this.port = options.port;
    this.localAddress = options.localAddress;
    this.dns = options.dns;

    this.init();
  }

  init() {
    this.socket.on('error', (err) => {
      this.logger.error(err);
      if (!this.socket.destroyed) {
        return this.socket.destroy();
      }
    });

    this.socket.on('timeout', () => {
      this.logger.warn('socket timeout');
      this.socket.end();
    });
  }

  consume() {
    return new Promise((resolve) => {
      this.socket.once('data', resolve);
    });
  }

  //  +----+------+----------+------+----------+
  //  |VER | ULEN |  UNAME   | PLEN |  PASSWD  |
  //  +----+------+----------+------+----------+
  //  | 1  |  1   | 1 to 255 |  1   | 1 to 255 |
  //  +----+------+----------+------+----------+

  // @ts-ignore

  //   +----+----------+----------+
  //   |VER | NMETHODS | METHODS  |
  //   +----+----------+----------+
  //   | 1  |    1     | 1 to 255 |
  //   +----+----------+----------+
  // @ts-ignore

  //   +----+-----+-------+------+----------+----------+
  //   |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
  //   +----+-----+-------+------+----------+----------+
  //   | 1  |  1  | X'00' |  1   | Variable |    2     |
  //   +----+-----+-------+------+----------+----------+

  //   o  X'00' succeeded
  //   o  X'01' general SOCKS server failure
  //   o  X'02' connection not allowed by ruleset
  //   o  X'03' Network unreachable
  //   o  X'04' Host unreachable
  //   o  X'05' Connection refused
  //   o  X'06' TTL expired
  //   o  X'07' Command not supported
  //   o  X'08' Address type not supported
  //   o  X'09' to X'FF' unassigned

  reply(rep, address: any = null) {
    const data = [0x05, rep, 0x00];

    if (!address) {
      this.socket.write(Buffer.from(data.concat([0x01, 0, 0, 0, 0, 0, 0])));
      return;
    }

    // this.logger.debug(address);

    if (address.family === 'IPv4') {
      data.push(0x01);
      for (const str of address.address.split('.')) {
        data.push(Number(str));
      }
    } else if (address.family === 'IPv6') {
      data.push(0x04);
      const ipv6BufArr = ipv6.toBufArr(address.address);
      for (const byte of ipv6BufArr) {
        data.push(byte);
      }
    }

    data.push(address.port >> 8);
    data.push(address.port & 0xff);

    this.socket.write(Buffer.from(data));
  }

  async request(data) {
    // Requests

    //   +----+-----+-------+------+----------+----------+
    //   |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
    //   +----+-----+-------+------+----------+----------+
    //   | 1  |  1  | X'00' |  1   | Variable |    2     |
    //   +----+-----+-------+------+----------+----------+

    // const data: any = await this.consume();
    // @ts-ignore
    if (data[0] != 0x05) {
      this.logger.error('Unsupported SOCKS version: %d', data[0]);
      return this.socket.end();
    }

    // o  CONNECT X'01'
    // o  BIND X'02'
    // o  UDP ASSOCIATE X'03'
    // @ts-ignore
    if (data[1] == 0x01) {
      // CONNECT METHOD REQUEST
      // @ts-ignore
      if (data[2] !== 0x00) this.logger.warn('RESERVED should be 0x00');
      let dstHost, dstPort;
      // @ts-ignore
      switch (data[3]) {
        case 0x01: // ipv4
          dstHost = `${data[4]}.${data[5]}.${data[6]}.${data[7]}`;
          dstPort = (data[8] << 8) | data[9];
          break;
        case 0x03: {
          // domain
          const domainLen = data[4];
          const domain = data.toString('ascii', 5, 5 + domainLen);
          try {
            const dnsResolver = new Resolver();
            if (this.dns && typeof this.dns === 'string') {
              dnsResolver.setServers([this.dns]);
            } else if (this.dns && typeof this.dns === 'object') {
              dnsResolver.setServers(this.dns);
            }
            if (this.localAddress) {
              dnsResolver.setLocalAddress(this.localAddress);
            }
            // @ts-ignore
            const ips = await dnsResolver.resolve4(domain);
            dstHost = ips[0];
          } catch (err) {
            //fix
            if (net.isIP(domain)) {
              dstHost = domain;
            } else {
              this.logger.error(err);
              this.reply(0x04);
              return this.socket.end();
            }
          }
          dstPort = (data[5 + domainLen] << 8) | data[5 + domainLen + 1];
          break;
        }
        case 0x04: {
          // ipv6
          const addrBuf = data.slice(4, 20);
          dstHost = ipv6.toStr(addrBuf);
          dstPort = (data[20] << 8) | data[21];
          break;
        }
        default:
          this.logger.error(`ATYP ${data[3]} not support`);
          this.reply(0x08);
          return this.socket.end();
      }

      this.createConnection(dstHost, dstPort);
    } else if (data[1] == 0x02) {
      //BIND METHOD REQUEST
      this.logger.error('BIND METHOD REQUEST not support');
      this.reply(0x07);
      return this.socket.end();
    } else if (data[1] == 0x03) {
      //UDP ASSOCIATE METHOD REQUEST
      // @ts-ignore
      this.reply(0x00, { address: '0.0.0.0', family: 'IPv4', port: this.port });
      return this.socket.end();
    } else {
      this.logger.error('Unsupported method: %d', data[1]);
      this.reply(0x07);
      return this.socket.end();
    }
  }

  private createConnection(dstHost, dstPort, retries = 3) {
    if (retries <= 0) {
      this.logger.error(
        'Connection retries exceeded',
        dstHost,
        dstPort,
        retries
      );
      this.reply(0x05);
      return this.socket.end();
    }

    let replyed = false;
    const proxy = net.createConnection({
      host: dstHost,
      port: dstPort,
      localAddress: this.localAddress ? this.localAddress : undefined,
    });
    proxy.on('error', (err) => {
      this.logger.error(err);
      this.createConnection(dstHost, dstPort, retries - 1);
    });

    proxy.on('timeout', () => {
      this.logger.warn('proxy timeout');
      if (!replyed) {
        // X'05' Connection refused
        this.reply(0x05);
      }
      proxy.end();
      this.socket.end();
    });

    proxy.once('connect', () => {
      this.reply(0x00, proxy.address());
      replyed = true;
      proxy.pipe(this.socket, { end: false });
      this.socket.pipe(proxy, { end: false });
    });

    proxy.once('close', () => {
      // use set timeout to avoid - Error: This socket has been ended by the other party at Socket.writeAfterFIN
      // setTimeout(() => {
      this.socket.end();
      // }, 3000);
    });
  }

  async handle(data) {
    console.log('socks5 incoming req')
    this.request(data).then();
  }
}
