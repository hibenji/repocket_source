
function checkInternet(cb) {
  require('dns').lookup('google.com',function(err) {
      if (err && err.code == "ENOTFOUND") {
          cb(false);
      } else {
          cb(true);
      }
  })
}


interface ConnectionMonitorActions {
  onConnectionDeactivate: Function,
  onConnectionActive: Function
}

export class ConnectionMonitor {
  second = 7;
  interval: NodeJS.Timer | null | undefined;
  isRunning = false;
  isConnectionActive = false;
  duration = 60000;
  // onPeerDeactivate;

  init() {
    console.debug('ConnectionMonitor -> onInit');
  }

  start({ onConnectionDeactivate, onConnectionActive }: ConnectionMonitorActions) {
    // runs every 30 seconds
    if (this.interval == null) {
      this.isRunning = true;
      this.interval = setInterval(() => {
        this.monitorHandler(
          async () => {
            await onConnectionDeactivate();
          },
          async () => {
            await onConnectionActive();
          }
        );
      }, this.duration);
    }
  }

  stop() {
    if (this.interval != null) {
      this.isRunning = false;
      clearInterval(this.interval?.[Symbol.toPrimitive]());
      this.interval = null;
      console.debug('ConnectionMonitor -> Monitor Stopped.');
    }
  }

  async monitorHandler(onConnectionDeactivate: Function, onConnectionActive: Function) {
    console.debug(`Connection monitor is running`);

    try {
      await this.checkConnection();
      console.debug("Internet connection is present");
      await onConnectionActive();
    } catch (error) {
      console.debug("Internet connection is absent");
      await onConnectionDeactivate();
    }
  }

  async checkConnection() {
    return new Promise<void>(async (resolve, reject) => {
      try {

        checkInternet((isOnline) => {
          if (!isOnline) {
            reject();
          }
          resolve();
        })
  
      } catch {
        reject();
      }
    });
  }
}