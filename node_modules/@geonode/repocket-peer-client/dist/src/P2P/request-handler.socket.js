"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestHandlerSocket = void 0;
const net_1 = require("net");
//  todo - fix imports
const P2P_service_1 = require("../services/P2P.service");
const events_1 = __importDefault(require("events"));
const target_socket_1 = require("./target.socket");
const helpers_1 = require("./helpers");
const socks5_socket_1 = require("./socks5/socks5.socket");
class ReqHandlerSocket extends net_1.Socket {
}
class RequestHandlerSocket {
    constructor(ip, port, reqId, peerId) {
        this.emitter = new events_1.default();
        this.isSocks5Req = false;
        this._ip = ip;
        this._port = port;
        this._reqId = reqId;
        this._peerId = peerId;
    }
    connect() {
        this.socket = new net_1.Socket();
        this.socket.retryConnectionCounter = 0;
        this.socket.type = 'main';
        this.socket.uid = Math.random();
        this.socket.isBusy = false;
        this.socket.setNoDelay(true);
        this.socket.on('data', async (data) => {
            await this.onData(data);
        });
        this.socket.on('error', (error) => {
            this.onError(error);
        });
        this.socket.on('timeout', () => {
            console.log('Socket timeout');
            this.socket.emit('error', new Error('Timeout occurred'));
            this.socket.end();
        });
        this.socket.on('close', () => {
            this.onClose();
        });
        this.socket.connect(this._port, this._ip, () => {
            console.log(`new socket req - ${this._reqId}`);
        });
    }
    // socketServer: RPSocket,
    async httpProtocolHandler(data, buffer) {
        // RPLogger.log('handling HTTPS | HTTP');
        const request = this.parseHttpRequest(data);
        if (!request)
            return;
        const port = request['port'] != null ? request['port'] : 80;
        try {
            this.targetSocket = new target_socket_1.TargetSocket(this.socket, request, buffer);
            this.targetSocket.emitter.on(P2P_service_1.P2PEvents.onTargetWebsiteError, (e) => this.emitter.emit(P2P_service_1.P2PEvents.onTargetWebsiteError, null, e));
            this.targetSocket.connect();
        }
        catch (e) {
            console.log('e :', e);
            return;
        }
    }
    async _handleRead(data) {
        // authentication
        const request = String.fromCharCode(...new Uint8Array(data.buffer));
        const reqAsStr = request.toString();
        const isAuthPacket = reqAsStr == P2P_service_1.PeerSocketEvents['Authentication'];
        const isRemoteSocketClosePacket = reqAsStr == P2P_service_1.PeerSocketEvents['RemoteSocketClosed'];
        const httpFirstLineRegex = /^(GET|HEAD|POST|PUT|DELETE|OPTIONS|TRACE|PATCH|CONNECT) (\S+\s+HTTP\/1\.(0|1)(\r\n([A-Za-z0-9-_]+:\s+[\S ]+)?)+\r\n\r\n.*)*$/;
        if (isAuthPacket) {
            // RPLogger.log('RequestHandlerSocket -> Authentication');
            this.socket.write(`authentication ${this._peerId} ${this._reqId}`);
            return;
        }
        else if (isRemoteSocketClosePacket) {
            // RPLogger.log('received RemoteSocketClosed');
            if (this.targetSocket != null) {
                // RPLogger.log('on end');
                this.targetSocket.socket.end();
                // targetSocket.close();
            }
        }
        else if (this.targetSocket != null) {
            // RPLogger.log('writing data to targetSocket');
            try {
                (0, helpers_1.writeToSocket)(this.targetSocket.socket, data);
            }
            catch (e) {
                console.log('e :', e);
            }
            return;
        }
        else if (this.isSocks5Req) {
            // write events handled by pipe method on the socket for socks5
            return;
        }
        if (request.toString().startsWith('CONNECT') ||
            request.toString().includes('HTTP/1.1') ||
            httpFirstLineRegex.test(request.toString())) {
            // http/https
            this.socket.isBusy = true;
            return await this.httpProtocolHandler(request, data);
        }
        else if (this.isSocks5Request(data)) {
            // socks5
            this.isSocks5Req = true;
            this.socks5targetSocket = new socks5_socket_1.Socket5Handler(this.socket, {});
            this.socks5targetSocket.handle(data).then();
        }
    }
    isSocks5Request(buffer) {
        if (!buffer)
            return;
        // Check if buffer length is at least 10 bytes || Check SOCKS version || Check command code || Check reserved byte
        if (buffer.length < 10 ||
            buffer[0] !== 5 ||
            buffer[1] !== 1 ||
            buffer[2] !== 0) {
            return false;
        }
        return true;
    }
    async onData(data) {
        try {
            await this._handleRead(data);
        }
        catch (e) {
            console.log('e :', e);
        }
    }
    onError(error) {
        console.log(`onError: error when connecting to socket-server: ${error}`);
        this.emitter.emit(P2P_service_1.P2PEvents.onSocketConnectionFailed, null, error);
        this.socket.end();
    }
    onClose() {
        console.log(' RequestHandlerSocket ->  onClose => ', this._reqId);
        this.socket.end();
    }
    parseHttpVer10(data) {
        const splitted = data.split(' ');
        return {
            method: splitted[0],
            path: splitted[1].split(':')[0],
            httpVersion: splitted[2].split('\r')[0],
            host: splitted[1].split(':')[0],
            port: splitted[1].split(':')[1],
        };
    }
    parseHttpRequest(data) {
        try {
            if (data && data.includes('HTTP/1.0')) {
                return this.parseHttpVer10(data);
            }
            const getPort = (host_header) => {
                var port;
                if (host_header.split(':').length > 2) {
                    port = Number(host_header.split(':')[2].trim());
                }
                return port || 80;
            };
            const getHostIndex = (splitted) => {
                return splitted.findIndex((l) => l.toLowerCase().includes('host:') &&
                    l.toLowerCase().startsWith('host: '));
            };
            const splitted = data.split('\r\n');
            const firstLine = splitted[0].trim().split(' ');
            const method = firstLine[0];
            const path = firstLine[1];
            const httpVersion = firstLine[2];
            const index = getHostIndex(splitted);
            const host = splitted[index].split(':')[1].trim();
            const port = getPort(splitted[index]);
            return {
                method,
                path,
                httpVersion,
                host,
                port,
            };
        }
        catch (e) {
            console.log('e parseHttpRequest:', e);
            return null;
        }
    }
}
exports.RequestHandlerSocket = RequestHandlerSocket;
