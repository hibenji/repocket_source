"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TargetSocket = void 0;
const net_1 = __importDefault(require("net"));
const events_1 = __importDefault(require("events"));
const P2P_service_1 = require("../services/P2P.service");
class TargetSocket {
    constructor(requestHandlerSocket, request, buffer) {
        this.emitter = new events_1.default();
        this.requestHandlerSocket = requestHandlerSocket;
        this.request = request;
        this.buffer = buffer;
    }
    connect() {
        // RPLogger.log('handling HTTPS | HTTP');
        if (!this.request)
            return;
        const port = this.request['port'] != null ? this.request['port'] : 80;
        try {
            this.socket = new net_1.default.Socket();
            this.socket.setTimeout(30000); // was 10 before
            this.socket.setNoDelay(true);
            this.socket.on('connect', () => { });
            // this.socket.on('data', (buffer) => this.onSocketDataEvent(buffer));
            this.socket.on('error', async (e) => this.onSocketErrorEvent(e)); //   todo - need to error target website error
            this.socket.on('close', async () => this.onSocketCloseEvent());
            // @ts-ignore
            this.socket.pipe(this.requestHandlerSocket);
            this.socket.connect(port.toString(), this.request['host']);
        }
        catch (e) {
            console.log('e :', e);
            return;
        }
        if (this.isHttps()) {
            this.requestHandlerSocket.write(`${this.request['httpVersion']} 200 Connection Established\r\n\r\n`);
        }
        if (!this.isHttps()) {
            try {
                this.socket.write(this.buffer);
            }
            catch (e) {
                console.log('targetSocket.write error: ${e}');
            }
        }
    }
    isHttps() {
        return this.request['method'].toLowerCase() == 'connect';
    }
    onSocketCloseEvent() {
        // console.log('TargetSocket -> onSocketCloseEvent ');
        // this requestHandlerSocket should be close already, but we verify it here
        setTimeout(() => {
            this.requestHandlerSocket?.end();
        }, 3000);
    }
    onSocketErrorEvent(error) {
        this.emitter.emit(P2P_service_1.P2PEvents.onTargetWebsiteError, null, error);
    }
}
exports.TargetSocket = TargetSocket;
