"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const services_1 = require("../services");
const peer_service_1 = __importDefault(require("../services/peer.service"));
function nodeLogIn(email, api_key) {
    return new Promise((resolve, reject) => {
        services_1.peerManagerApiService
            .post('peer/token', { email: email, api_key: api_key })
            .then((result) => {
            if (result.status === 200) {
                resolve({ peerApiToken: result.data.token, userId: result.data.user_id });
                // storage.set('p-api-token', result.data.token);
                // storage.set('userId', result.data.user_id);
            }
            else {
                switch (result.error?.code) {
                    case 'auth/user-not-found':
                        reject({ error: 'auth/user-not-found' });
                        return;
                    case 'auth/wrong-password':
                        reject({ error: 'auth/wrong-password' });
                        return;
                    default:
                        reject({ error: result.error?.code });
                        return;
                }
            }
        })
            .catch((e) => {
            reject({ error: e });
            return;
        });
    });
}
nodeLogIn('adirsimona@gmail.com', '53ecbb9c-deb4-49e9-8819-621d6ecb8aa8')
    .then(async (res) => {
    console.log('login complete');
    const { userId, peerApiToken } = res;
    const peerService = new peer_service_1.default({ peerApiToken, userId });
    await connectPeer(peerService);
}).catch((e) => {
    console.log('e', e);
});
async function connectPeer(service) {
    const min_to_wait = 15;
    const max_to_wait = 90;
    const getRandomSeconds = () => 10;
    try {
        const peerConnected = await service.createPeer();
        if (peerConnected) {
            service.events.on(service.EVENTS_NAMES.connected, () => {
                console.log('peer connected');
            });
            service.events.on(service.EVENTS_NAMES.connecting, () => {
                console.log('peer resetting');
            });
            service.events.on(service.EVENTS_NAMES.disconnected, () => {
                console.log('peer disconnected');
            });
            service.events.on(service.EVENTS_NAMES.peer_server_502_error, () => {
                console.log(`peer_server_520_error, reconnecting in ${min_to_wait}-${max_to_wait} seconds...`);
                setTimeout(() => {
                    connectPeer(service);
                }, 1000 * getRandomSeconds());
            });
            service.events.on(service.EVENTS_NAMES.refresh_token_required, () => {
                console.log('peer refresh_token_required');
            });
        }
        else {
            setTimeout(() => {
                connectPeer(service);
            }, 1000 * getRandomSeconds());
        }
    }
    catch (error) {
        setTimeout(() => {
            connectPeer(service);
        }, 1000 * getRandomSeconds());
    }
}
function killProcess() {
    process.exit();
}
process.on('SIGTERM', killProcess);
process.on('SIGINT', killProcess);
process.on('uncaughtException', function (e) {
    console.log('[uncaughtException]: ', e.stack);
    killProcess();
});
