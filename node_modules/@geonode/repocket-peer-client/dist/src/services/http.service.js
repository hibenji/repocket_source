"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const store2_1 = __importDefault(require("store2"));
const runtime_info_1 = require("../shared/runtime-info");
class HttpService {
    constructor() {
        this.httpInterceptingHandler = async (config) => {
            this.accessTokenHandler(config);
            config.headers['x-app-verison'] = runtime_info_1.runtimeInfo.appVersion;
            if (runtime_info_1.runtimeInfo.isDocker) {
                config.headers['device-os'] = 'node';
            }
            else if (runtime_info_1.runtimeInfo.isMac) {
                config.headers['device-os'] = 'mac';
            }
            else if (runtime_info_1.runtimeInfo.isWindows) {
                config.headers['device-os'] = 'windows';
            }
            else if (runtime_info_1.runtimeInfo.isLinux) {
                config.headers['device-os'] = 'linux';
            }
            // await authService.accessTokenHandler(config);
            // need to add http auth basic
            return config;
        };
        this.httpResponseHandler = (response) => {
            if (response && response.data) {
                const { data } = response;
                if (data.message && data.showNotification) {
                    const { title, body, variant } = data.message;
                    // notificationService.openNotification({
                    //   title: title,
                    //   html: body,
                    //   variant: variant || 'success',
                    // });
                }
            }
            return response;
        };
        // @ts-ignore
        this.httpResponseErrorHandler = async (data) => {
            const response = data && data.response;
            if (response) {
                // 401 un auth user
                if (response.status === 401) {
                    if (response?.data?.message && response?.data?.showNotification) {
                    }
                }
                if (response.data.err && response.data.status !== 402) {
                    if (response?.data?.showNotification) {
                    }
                }
                if (response.data) {
                    // globals.growlRef.show({severity: 'error', summary: 'Error Message', detail: (typeof resp.error === 'string') ? resp.error  : ''});
                    return Promise.reject({ data: response.data, status: response.status });
                    // Alert.alert('Error', resp.error);
                }
            }
            else {
                return Promise.reject({});
            }
        };
        this.axios = axios_1.default.create();
        this.axios.interceptors.request.use((config) => this.httpInterceptingHandler(config));
        // response => response
        this.axios.interceptors.response.use((response) => this.httpResponseHandler(response), (error) => this.httpResponseErrorHandler(error));
    }
    // CRUD
    get(url, params) {
        return this.axios.get(url, { params });
    }
    post(url, payload) {
        return this.axios.post(url, payload);
    }
    put(url, payload) {
        return this.axios.put(url, payload);
    }
    delete(url, data) {
        return this.axios.delete(url, { data });
    }
    async accessTokenHandler(config) {
        const accessToken = store2_1.default.get('loginToken');
        const peerToken = store2_1.default.get('p-api-token');
        const sdkApiKey = store2_1.default.get('sdk-api-key');
        //if token is found add it to the header
        if (accessToken || peerToken || sdkApiKey) {
            if (config.method !== 'OPTIONS') {
                if (accessToken && !peerToken)
                    config.headers['auth-token'] = accessToken; // firebase
                if (peerToken)
                    config.headers['p-auth-token'] = peerToken; // apiKey
                if (sdkApiKey) {
                    config.headers['api-key'] = sdkApiKey;
                    config.headers['x-sdk-version'] = runtime_info_1.runtimeInfo.appVersion;
                }
            }
        }
    }
}
exports.default = HttpService;
