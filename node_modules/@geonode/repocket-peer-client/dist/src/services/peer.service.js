"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debounce_1 = require("debounce");
const axios_1 = __importDefault(require("axios"));
const store2_1 = __importDefault(require("store2"));
const P2P_service_1 = require("./P2P.service");
const index_1 = require("./index");
const utils_1 = require("../shared/utils");
const PeerMonitor_class_1 = require("../classes/PeerMonitor.class");
const VPNWatcher_class_1 = require("../classes/VPNWatcher.class");
const ConnectionMonitor_class_1 = require("../classes/ConnectionMonitor.class");
const node_events_1 = require("node:events");
const ENDPOINTS = {
    CREATE_PEER: 'peer/createPeer',
    PEER_CONFIG: 'peer/config',
};
// @singleton
class PeerService {
    constructor(options) {
        // static final PeerService _instance = PeerService._internal();
        this.EVENTS_NAMES = {
            connected: 'connected',
            disconnected: 'disconnected',
            connecting: 'connecting',
            refresh_token_required: 'refresh_token_required',
            peer_server_error: 'peer_server_error',
        };
        this.isUserActivatedThePeer = true; // peer should be active by default
        this.isPeerActive = false;
        this.isResettingPeer = false;
        this.isCreatingPeer = false;
        this.isConnectivityChanged = false;
        this.shouldResetConnection = false;
        this.peerId = null;
        this.peerMonitor = new PeerMonitor_class_1.PeerMonitor();
        this.connectionMonitor = new ConnectionMonitor_class_1.ConnectionMonitor();
        this.vpnWatcher = new VPNWatcher_class_1.VPNWatcher();
        this.enabledLocalMonitor = false;
        this.tcpServerInfo = null;
        this.auth = { username: 'test', password: 'test' };
        this.events = new node_events_1.EventEmitter();
        this.settings = {
            peerMonitorRate: 120000,
        };
        this.resetPeerDebounce = (0, debounce_1.debounce)(async () => {
            console.debug(`PeerService(${this.localId}) -> resetPeer`);
            // isPeerActive.value = false;
            await this._stop();
            this.events.emit(this.EVENTS_NAMES.connecting);
            setTimeout(async () => {
                try {
                    await this.createPeer();
                }
                catch (error) {
                    console.error(error);
                }
            }, 3000);
            setTimeout(() => {
                this.isResettingPeer = false;
            }, 5000);
        }, 1000);
        this.handleConnectionClosedDebounce = (0, debounce_1.debounce)(async () => {
            console.debug(`PeerService(${this.localId}) -> _handleConnectionClosed`);
            this.events.emit(this.EVENTS_NAMES.disconnected);
            if (this._shouldReconnectThePeer()) {
                setTimeout(async () => {
                    await this._resetPeer();
                }, 3000);
            }
            else {
                if (!this.isUserActivatedThePeer) {
                    await this.deletePeer();
                }
            }
        }, 1000);
        this.deletePeerDebounce = (0, debounce_1.debounce)(async () => {
            console.debug('deletePeerDebounce');
            await this._stop();
        }, 1000);
        this.localId = Math.floor(1000 + Math.random() * 9000);
        const { firebaseLoginToken, peerApiToken, sdkApiKey, userId } = options;
        if (!firebaseLoginToken && !peerApiToken && !sdkApiKey) {
            throw new Error('firebaseLoginToken or peerApiToken or sdkApiKey is required');
        }
        if (firebaseLoginToken)
            store2_1.default.set('loginToken', firebaseLoginToken);
        if (sdkApiKey)
            store2_1.default.set('sdk-api-key', sdkApiKey);
        if (peerApiToken)
            store2_1.default.set('p-api-token', peerApiToken);
        if (userId)
            store2_1.default.set('userId', userId);
    }
    _shouldReconnectThePeer() {
        return this.isUserActivatedThePeer;
    }
    async createPeer() {
        if (this.isCreatingPeer || this.isPeerActive)
            return false;
        this.isCreatingPeer = true;
        try {
            // Starting the local monitor before anything else, in case connection gets stuck and it never gets to peerMonitor or connectionMonitor init
            this.startLocalPeerMonitor();
            //  1. getting speed test
            //  2. getting device info
            const ipInfo = await this.getIpInfo();
            const deviceInfo = await (0, utils_1.getDeviceInfo)();
            // //   3. getting ip info
            // 4. check connectivity
            const isConnectivityCheck = true; // await ConnectivityData.connectivityCheck();  todo : complete logic
            // 5. check VPN status
            const isVpnConnect = false; // await isVpnActive(); todo : complete logic
            // 6. establish connection - POST /api/peer/createPeer - payload: { ip, username, password, userId, userDeviceInfo, speedTestInfo }
            if (isConnectivityCheck && !isVpnConnect) {
                let userId = store2_1.default.get('userId');
                let settings = this.settings;
                console.debug(`PeerService(${this.localId}) -> creating peer userId -> ${userId}`);
                // If we don't get a response we still want to be able to use the default values, hence the try/catch
                try {
                    let remoteSettings = await index_1.peerManagerApiService.get(ENDPOINTS.PEER_CONFIG);
                    let versionToken = remoteSettings.data.data.config_version_token;
                    store2_1.default.set('configVersionToken', versionToken);
                    this.settings = settings;
                }
                catch (error) {
                    console.debug('Failed to get settings');
                }
                let response = await index_1.peerManagerApiService.post('peer/createPeer', {
                    ip: ipInfo?.query,
                    username: 'test',
                    password: 'test',
                    userId: userId,
                    userDeviceInfo: deviceInfo,
                });
                if (response) {
                    console.debug(`PeerService(${this.localId}) -> creating peer response -> ${response.status}`);
                    response = response['data']['data'];
                    this.peerId = response['_id'];
                    let token = response['token'];
                    this.tcpServerInfo = response['tcpServerInfo'];
                    if (!userId) {
                        userId = response['userId'];
                        store2_1.default.set('userId', userId);
                    }
                    this.P2PServiceInstance = new P2P_service_1.P2PService({
                        ip: this.tcpServerInfo['ip'],
                        port: this.tcpServerInfo['port'],
                        socketReqHandlerPort: this.tcpServerInfo['socketReqHandlerPort'],
                        peerId: this.peerId,
                        userId: userId,
                        token: token,
                    });
                    this._registerEventListeners();
                    // listenToConnectivityChanges();
                    const isSocketConnected = await this.P2PServiceInstance?.startSocketConnection();
                    if (isSocketConnected) {
                        this.isUserActivatedThePeer = true;
                        this.isPeerActive = true;
                    }
                    this.isCreatingPeer = false;
                    return Boolean(isSocketConnected);
                }
                else {
                    this.isCreatingPeer = false;
                    return false;
                }
            }
            else {
                this.isCreatingPeer = false;
                return false;
            }
        }
        catch (error) {
            this.isCreatingPeer = false;
            console.error(error);
            console.info(`PeerService(${this.localId}) -> Failed to create connection: ${error?.data?.message}`);
            if (error?.status === 403 || error?.status === 401) {
                this.events.emit(this.EVENTS_NAMES.refresh_token_required);
            }
            const statusCode = error?.status;
            this.handleManagerServerError(statusCode);
            return false;
        }
    }
    handleManagerServerError(statusCode) {
        if (!statusCode)
            return;
        const isServerErrorResponse = statusCode >= 500 && statusCode <= 599;
        if (isServerErrorResponse) {
            this.events.emit(this.EVENTS_NAMES.peer_server_error);
        }
    }
    async _handleConnectionClosed() {
        this.handleConnectionClosedDebounce();
    }
    _registerEventListeners() {
        const onSocketConnectionFailedDebounce = (0, debounce_1.debounce)(async () => {
            if (!this.isCreatingPeer && this.isConnectivityChanged) {
                await this._handleConnectionClosed();
            }
        }, 1000);
        const onReceiveDataDebounce = (0, debounce_1.debounce)(async () => {
            console.debug('onSocketConnectionFailed ${isUserActivatedThePeer.isTrue}');
            if (!this.isPeerActive) {
                this.isPeerActive = true;
                this.events.emit(this.EVENTS_NAMES.connected);
            }
        }, 1000);
        const onConnectionToServerFailedDebounce = (0, debounce_1.debounce)(async () => {
            console.debug('onConnectionToServerFailed ${isUserActivatedThePeer.isTrue}');
            this.events.emit(this.EVENTS_NAMES.disconnected);
            await this._stop();
        }, 1000);
        const onSocketConnectionCloseDebounce = (0, debounce_1.debounce)(async () => {
            console.debug('onSocketConnectionClose ${isUserActivatedThePeer.isTrue}');
            if (!this.isCreatingPeer) {
                // isPeerActive.value = false;
                setTimeout(async () => {
                    await this._handleConnectionClosed();
                }, 1000);
            }
        }, 1000);
        const onConnectionEstablishedDebounce = (0, debounce_1.debounce)(async () => {
            console.info(`PeerService(${this.localId}) -> Connection established`);
            await this._markPeerAsAlive();
        }, 1000);
        this.P2PServiceInstance?.emitter.on(P2P_service_1.P2PEvents.onBeforeStartSocketConnection, async () => {
            this.events.emit(this.EVENTS_NAMES.connecting);
            //  register all event listeners here
            this.P2PServiceInstance?.emitter.on(P2P_service_1.P2PEvents.onSocketConnectionFailed, async () => {
                //      if connection to socket failed
                if (!this.isCreatingPeer && !this.isConnectivityChanged) {
                    onSocketConnectionFailedDebounce();
                }
            });
            this.P2PServiceInstance?.emitter.on(P2P_service_1.P2PEvents.onReceiveData, async () => {
                //      if connection to socket failed
                onReceiveDataDebounce();
            });
            this.P2PServiceInstance?.emitter.on(P2P_service_1.P2PEvents.onConnectionToServerFailed, async () => {
                //      if connection to socket failed
                onConnectionToServerFailedDebounce();
            });
            this.P2PServiceInstance?.emitter.on(P2P_service_1.P2PEvents.onSocketConnectionClose, async () => {
                //      if connection to socket failed
                onSocketConnectionCloseDebounce();
            });
            this.P2PServiceInstance?.emitter.on(P2P_service_1.P2PEvents.onConnectionEstablished, async () => {
                onConnectionEstablishedDebounce();
            });
        });
    }
    async _resetPeer() {
        if (this.isResettingPeer)
            return;
        this.isResettingPeer = true;
        this.resetPeerDebounce();
    }
    async deletePeer(isForceStop = false) {
        if (this.isResettingPeer && isForceStop == false)
            return;
        if (isForceStop) {
            // EasyDebounce.cancel('delete-peer-debouncer');
            await this._stop();
        }
        else {
            this.deletePeerDebounce();
        }
    }
    async _stop(keepConnectionMonitor = false) {
        console.info(`PeerService(${this.localId}) -> Stop`);
        if (this.peerId) {
            this.peerMonitor.stop();
            if (!keepConnectionMonitor) {
                this.connectionMonitor.stop();
            }
            this.vpnWatcher.stop();
            this.events.emit(this.EVENTS_NAMES.disconnected);
            try {
                // todo - test it
                await index_1.peerManagerApiService.delete('peer/deletePeer', {
                    peerId: this.peerId,
                });
            }
            catch (error) {
                console.error(error);
                // if (error.status === 403) {
                //   await firebaseService?.refreshToken();
                // }
            }
            this.P2PServiceInstance?.end();
            this.P2PServiceInstance?.emitter.removeAllListeners();
            this.isPeerActive = false;
            this.peerId = null;
        }
    }
    async _markPeerAsAlive() {
        try {
            console.log('markPeerAsAlive -> start - ', this.peerId);
            const response = await index_1.peerManagerApiService.post('peer/markPeerAsAlive', {
                peerId: this.peerId,
            });
            const isAlive = response.status === 200;
            if (isAlive) {
                console.log('markPeerAsAlive -> isAlive');
                this.isPeerActive = true;
                this.events.emit(this.EVENTS_NAMES.connected);
                // retriesConnectionCounter = 0;
                this.isUserActivatedThePeer = true;
                this.startPeerMonitor().then();
                this.startConnectionMonitor().then();
                this.startVpnWatcher().then();
            }
        }
        catch (error) {
            console.error(`_markPeerAsAlive -> Error happened: ${error?.message} - ${error?.status}`);
            await this._resetPeer();
        }
    }
    async startPeerMonitor() {
        let userId = store2_1.default.get('userId');
        let versionToken = store2_1.default.get('configVersionToken');
        this.peerMonitor.init({
            peerId: this.peerId,
            userId: userId,
            configVersionToken: versionToken,
        });
        this.peerMonitor.start({
            onPeerDeactivate: async () => {
                await this._handleConnectionClosed();
            },
            onCredentialsMissing: async () => {
                await this._stop();
            },
            onPeerActive: async () => {
                this._verifyUIStatus();
            },
        }, this.settings.peerMonitorRate);
    }
    async startConnectionMonitor() {
        this.connectionMonitor.init();
        this.connectionMonitor.start({
            onConnectionDeactivate: async () => {
                if (!this.shouldResetConnection) {
                    this.shouldResetConnection = true;
                    await this._stop(true);
                }
            },
            onConnectionActive: async () => {
                if (this.shouldResetConnection) {
                    this.shouldResetConnection = false;
                    await this._resetPeer();
                }
            },
        });
    }
    startLocalPeerMonitor() {
        if (!this.enabledLocalMonitor) {
            this.enabledLocalMonitor = true;
            setInterval(() => {
                if (this.isResettingPeer || this.isCreatingPeer)
                    return;
                const isEnabled = store2_1.default.get('shareInternet');
                if (isEnabled) {
                    console.debug('startLocalPeerMonitor -> checking for unhandled disconnects');
                    const status = store2_1.default.get('connectionStatus');
                    if (status !== 'connected') {
                        console.debug('startLocalPeerMonitor -> not connected, checking internet connection');
                        const monitor = new ConnectionMonitor_class_1.ConnectionMonitor();
                        monitor.duration = 1000;
                        monitor.start({
                            onConnectionDeactivate: () => {
                                console.info('startLocalPeerMonitor -> No Internet connection');
                                monitor.stop();
                            },
                            onConnectionActive: () => {
                                console.debug('startLocalPeerMonitor -> Internet connection present, resetting peer');
                                monitor.stop();
                                this._resetPeer()
                                    .then(() => {
                                    console.debug(`startLocalPeerMonitor -> Reset peer after an unhandled disconnect`);
                                })
                                    .catch((error) => {
                                    console.error(`startLocalPeerMonitor -> Error resetting peer: ${error}`);
                                });
                            },
                        });
                    }
                }
            }, 34300);
        }
    }
    _verifyUIStatus() {
        this.isPeerActive = true;
        this.events.emit(this.EVENTS_NAMES.connected);
    }
    async startVpnWatcher() {
        let userId = store2_1.default.get('userId');
        this.vpnWatcher.init({
            peerId: this.peerId,
            userId: userId,
        });
        this.vpnWatcher.start({
            onVpnActivated: async () => {
                await this.deletePeer();
            },
        });
    }
    async getIpInfo() {
        // http://ip-api.com/json
        try {
            // todo - check with https://verification.repocket.co/api/peer/verification
            const response = await axios_1.default.get('http://ip-api.com/json');
            if (response.status == 200) {
                return response.data;
            }
            else {
                console.error('Something went wrong');
            }
        }
        catch (e) {
            console.error(e.toString());
        }
    }
}
exports.default = PeerService;
