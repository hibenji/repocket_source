"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionMonitor = void 0;
function checkInternet(cb) {
    require('dns').lookup('google.com', function (err) {
        if (err && err.code == "ENOTFOUND") {
            cb(false);
        }
        else {
            cb(true);
        }
    });
}
class ConnectionMonitor {
    constructor() {
        this.second = 7;
        this.isRunning = false;
        this.isConnectionActive = false;
        this.duration = 60000;
    }
    // onPeerDeactivate;
    init() {
        console.debug('ConnectionMonitor -> onInit');
    }
    start({ onConnectionDeactivate, onConnectionActive }) {
        // runs every 30 seconds
        if (this.interval == null) {
            this.isRunning = true;
            this.interval = setInterval(() => {
                this.monitorHandler(async () => {
                    await onConnectionDeactivate();
                }, async () => {
                    await onConnectionActive();
                });
            }, this.duration);
        }
    }
    stop() {
        if (this.interval != null) {
            this.isRunning = false;
            clearInterval(this.interval?.[Symbol.toPrimitive]());
            this.interval = null;
            console.debug('ConnectionMonitor -> Monitor Stopped.');
        }
    }
    async monitorHandler(onConnectionDeactivate, onConnectionActive) {
        console.debug(`Connection monitor is running`);
        try {
            await this.checkConnection();
            console.debug("Internet connection is present");
            await onConnectionActive();
        }
        catch (error) {
            console.debug("Internet connection is absent");
            await onConnectionDeactivate();
        }
    }
    async checkConnection() {
        return new Promise(async (resolve, reject) => {
            try {
                checkInternet((isOnline) => {
                    if (!isOnline) {
                        reject();
                    }
                    resolve();
                });
            }
            catch {
                reject();
            }
        });
    }
}
exports.ConnectionMonitor = ConnectionMonitor;
